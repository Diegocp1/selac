codon.index.matrix <- CreateCodonMutationMatrixIndexEvolveAA()
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
source('~/GitHub/selac/R/selac.R')
tree <- read.tree("../tests/testthat/rokasYeast.tre")
phy <- drop.tip(tree, "Calb")
phy <- reorder(x = phy, "pruningwise")
yeast.gene <- read.dna("../tests/testthat/gene1Yeast.fasta", format="fasta")
yeast.gene <- as.list(as.matrix(cbind(yeast.gene))[1:7,])
chars <- DNAbinToCodonNumeric(yeast.gene)
codon.data <- chars[phy$tip.label,]
aa.data <- ConvertCodonNumericDataToAAData(codon.data, numcode=1)
aa.optim <- apply(aa.data[, -1], 2, GetMaxName) #starting values for all, final values for majrule
aa.optim.full.list <- aa.optim
codon.freq.by.aa <- GetCodonFreqsByAA(codon.data[,-1], aa.optim, numcode=1)
codon.freq.by.gene <- GetCodonFreqsByGeneHMM(codon.data[,-1])
aa.optim.frame.to.add <- matrix(c("optimal", aa.optim), 1, dim(codon.data)[2])
colnames(aa.optim.frame.to.add) <- colnames(codon.data)
codon.data <- rbind(codon.data, aa.optim.frame.to.add)
codon.data <- SitePattern(codon.data, includes.optimal.aa=TRUE)
aa.optim = codon.data$optimal.aa
codon.index.matrix <- CreateCodonMutationMatrixIndexEvolveAA()
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
FastCreateAllCodonFixationProbabilityMatrices <- function(aa.distances=CreateAADistanceMatrix(), nsites, C=4, Phi=0.5, q=4e-7, Ne=5e6, include.stop.codon=TRUE, numcode=1, diploid=TRUE, flee.stop.codon.rate=0.9999999) {
n.codons <- dim(.codon.sets)[1]
aa.fixation.probs <- CreateAAFixationMatrixForEverything(aa.distances=aa.distances, nsites, C, Phi, q, Ne, include.stop.codon, numcode, diploid)
codon.aa <- .aa.translation[[.numcode.translation.idx[numcode]]]
codon.fixation.probs <- array(data=0, dim=c(n.codons, n.codons, length(.unique.aa)), dimnames=list(.codon.name, .codon.name, .unique.aa))
codon.seq <- sequence(n.codons)
for (i in codon.seq) {
aa1 <- codon.aa[i]
for (j in codon.seq) {
aa2 <- codon.aa[j]
if(sum(.codon.sets[i,] == .codon.sets[j,]) > 1) { #match at two or more sites
codon.fixation.probs[i,j, ] <- aa.fixation.probs[aa1, aa2, .unique.aa]
}
}
}
return(codon.fixation.probs)
}
TreeTraversalODE <- function(phy, Q_codon_array_vectored, liks.HMM, bad.likelihood=-100000, root.p) {
nb.tip <- length(phy$tip.label)
nb.node <- phy$Nnode
anc <- unique(phy$edge[,1])
TIPS <- 1:nb.tip
n.states <- dim(liks.HMM)[2]
comp <- numeric(nb.tip + nb.node)
num.desc <- table(phy$edge[,1])
num.desc.cs <- c(0, cumsum(num.desc))
#Start the postorder traversal indexing lists by node number:
for (i in 1:nb.node) {
focal <- anc[i]
desRows <- (num.desc.cs[i]+1):num.desc.cs[i+1]
desNodes <- phy$edge[desRows, 2]
v = rep(1, n.states)
for (desIndex in 1:num.desc[i]){
yini <- liks.HMM[desNodes[desIndex],]
times=c(0, phy$edge.length[desRows[desIndex]])
prob.subtree.cal.full <- lsoda(yini, times, func = "selacHMM", Q_codon_array_vectored, initfunc="initmod_selacHMM", dllname = "selacHMM")
######## THIS CHECKS TO ENSURE THAT THE INTEGRATION WAS SUCCESSFUL ###########
if(attributes(prob.subtree.cal.full)$istate[1] < 0){
return(bad.likelihood)
}else{
prob.subtree.cal <- prob.subtree.cal.full[-1,-1]
}
##############################################################################
if(prob.subtree.cal[1] < 0){
return(bad.likelihood)
}
v <- v * prob.subtree.cal
}
comp[focal] <- sum(v)
liks.HMM[focal,] <- v/comp[focal]
}
root.node <- nb.tip + 1L
if (is.na(sum(log(liks.HMM[root.node,])))){
return(bad.likelihood)
}else{
loglik <- -(sum(log(comp[-TIPS])) + log(sum(root.p * liks.HMM[root.node,])))
}
return(loglik)
}
GetLikelihoodSAC_CodonForSingleCharGivenOptimumHMMScoring <- function(charnum=1, codon.data, phy, Q_codon_array_vectored, root.p=NULL, scale.factor, anc.indices, return.all=FALSE) {
nb.tip <- length(phy$tip.label)
nb.node <- phy$Nnode
nl <- 64
#Now we need to build the matrix of likelihoods to pass to dev.raydisc:
liks <- matrix(0, nb.tip + nb.node, nl)
tip.idx <- 1:nb.tip
c.idx <- codon.data[tip.idx, charnum + 1] < 65
liks[tip.idx[c.idx], codon.data[tip.idx[c.idx], charnum + 1]] <- 1
liks[tip.idx[!c.idx], ] <- 1
liks[tip.idx[!c.idx], c(49, 51, 57)] <- 0
## Now HMM this matrix by pasting these together:
liks.stop.codon <- matrix(0,  nb.tip + nb.node, nl)
liks.HMM <- vector("list", 21)
liks.HMM[1:16] <- replicate(expr = liks, n = 16, simplify = FALSE)
liks.HMM[[17]] <- liks.stop.codon
liks.HMM[18:21] <- replicate(expr = liks, n = 4, simplify = FALSE)
liks.HMM <- do.call(cbind, liks.HMM)
#The result here is just the likelihood:
result <- -TreeTraversalODE(phy=phy, Q_codon_array_vectored=Q_codon_array_vectored, liks.HMM=liks.HMM, bad.likelihood=-100000, root.p=root.p)
ifelse(return.all, stop("return all not currently implemented"), return(result))
}
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
source('~/GitHub/selac/R/selac.R')
#FCPM
FastCreateAllCodonFixationProbabilityMatrices <- function(aa.distances=CreateAADistanceMatrix(), nsites, C=4, Phi=0.5, q=4e-7, Ne=5e6, include.stop.codon=TRUE, numcode=1, diploid=TRUE, flee.stop.codon.rate=0.9999999) {
n.codons <- dim(.codon.sets)[1]
aa.fixation.probs <- CreateAAFixationMatrixForEverything(aa.distances=aa.distances, nsites, C, Phi, q, Ne, include.stop.codon, numcode, diploid)
codon.aa <- .aa.translation[[.numcode.translation.idx[numcode]]]
codon.fixation.probs <- array(data=0, dim=c(n.codons, n.codons, length(.unique.aa)), dimnames=list(.codon.name, .codon.name, .unique.aa))
codon.seq <- sequence(n.codons)
for (i in codon.seq) {
aa1 <- codon.aa[i]
for (j in codon.seq) {
aa2 <- codon.aa[j]
if(sum(.codon.sets[i,] == .codon.sets[j,]) > 1) { #match at two or more sites
codon.fixation.probs[i,j, ] <- aa.fixation.probs[aa1, aa2, .unique.aa]
}
}
}
return(codon.fixation.probs)
}
tree <- read.tree("../tests/testthat/rokasYeast.tre")
phy <- drop.tip(tree, "Calb")
phy <- reorder(x = phy, "pruningwise")
yeast.gene <- read.dna("../tests/testthat/gene1Yeast.fasta", format="fasta")
yeast.gene <- as.list(as.matrix(cbind(yeast.gene))[1:7,])
chars <- DNAbinToCodonNumeric(yeast.gene)
codon.data <- chars[phy$tip.label,]
aa.data <- ConvertCodonNumericDataToAAData(codon.data, numcode=1)
aa.optim <- apply(aa.data[, -1], 2, GetMaxName) #starting values for all, final values for majrule
aa.optim.full.list <- aa.optim
codon.freq.by.aa <- GetCodonFreqsByAA(codon.data[,-1], aa.optim, numcode=1)
codon.freq.by.gene <- GetCodonFreqsByGeneHMM(codon.data[,-1])
aa.optim.frame.to.add <- matrix(c("optimal", aa.optim), 1, dim(codon.data)[2])
colnames(aa.optim.frame.to.add) <- colnames(codon.data)
codon.data <- rbind(codon.data, aa.optim.frame.to.add)
codon.data <- SitePattern(codon.data, includes.optimal.aa=TRUE)
aa.optim = codon.data$optimal.aa
codon.index.matrix <- CreateCodonMutationMatrixIndexEvolveAA()
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
#FCPM
FastCreateAllCodonFixationProbabilityMatrices <- function(aa.distances=CreateAADistanceMatrix(), nsites, C=4, Phi=0.5, q=4e-7, Ne=5e6, include.stop.codon=TRUE, numcode=1, diploid=TRUE, flee.stop.codon.rate=0.9999999) {
n.codons <- dim(.codon.sets)[1]
aa.fixation.probs <- CreateAAFixationMatrixForEverything(aa.distances=aa.distances, nsites, C, Phi, q, Ne, include.stop.codon, numcode, diploid)
codon.aa <- .aa.translation[[.numcode.translation.idx[numcode]]]
codon.fixation.probs <- array(data=0, dim=c(n.codons, n.codons, length(.unique.aa)), dimnames=list(.codon.name, .codon.name, .unique.aa))
codon.seq <- sequence(n.codons)
for (i in codon.seq) {
aa1 <- codon.aa[i]
for (j in codon.seq) {
aa2 <- codon.aa[j]
if(sum(.codon.sets[i,] == .codon.sets[j,]) > 1) { #match at two or more sites
codon.fixation.probs[i,j, ] <- aa.fixation.probs[aa1, aa2, .unique.aa]
}
}
}
return(codon.fixation.probs)
}
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
source('~/GitHub/selac/R/selac.R')
#TTODE
TreeTraversalODE <- function(phy, Q_codon_array_vectored, liks.HMM, bad.likelihood=-100000, root.p) {
nb.tip <- length(phy$tip.label)
nb.node <- phy$Nnode
anc <- unique(phy$edge[,1])
TIPS <- 1:nb.tip
n.states <- dim(liks.HMM)[2]
comp <- numeric(nb.tip + nb.node)
num.desc <- table(phy$edge[,1])
num.desc.cs <- c(0, cumsum(num.desc))
#Start the postorder traversal indexing lists by node number:
for (i in 1:nb.node) {
focal <- anc[i]
desRows <- (num.desc.cs[i]+1):num.desc.cs[i+1]
desNodes <- phy$edge[desRows, 2]
v = rep(1, n.states)
for (desIndex in 1:num.desc[i]){
yini <- liks.HMM[desNodes[desIndex],]
times=c(0, phy$edge.length[desRows[desIndex]])
prob.subtree.cal.full <- lsoda(yini, times, func = "selacHMM", Q_codon_array_vectored, initfunc="initmod_selacHMM", dllname = "selacHMM")
######## THIS CHECKS TO ENSURE THAT THE INTEGRATION WAS SUCCESSFUL ###########
if(attributes(prob.subtree.cal.full)$istate[1] < 0){
return(bad.likelihood)
}else{
prob.subtree.cal <- prob.subtree.cal.full[-1,-1]
}
##############################################################################
if(prob.subtree.cal[1] < 0){
return(bad.likelihood)
}
v <- v * prob.subtree.cal
}
comp[focal] <- sum(v)
liks.HMM[focal,] <- v/comp[focal]
}
root.node <- nb.tip + 1L
if (is.na(sum(log(liks.HMM[root.node,])))){
return(bad.likelihood)
}else{
loglik <- -(sum(log(comp[-TIPS])) + log(sum(root.p * liks.HMM[root.node,])))
}
return(loglik)
}
tree <- read.tree("../tests/testthat/rokasYeast.tre")
phy <- drop.tip(tree, "Calb")
phy <- reorder(x = phy, "pruningwise")
yeast.gene <- read.dna("../tests/testthat/gene1Yeast.fasta", format="fasta")
yeast.gene <- as.list(as.matrix(cbind(yeast.gene))[1:7,])
chars <- DNAbinToCodonNumeric(yeast.gene)
codon.data <- chars[phy$tip.label,]
aa.data <- ConvertCodonNumericDataToAAData(codon.data, numcode=1)
aa.optim <- apply(aa.data[, -1], 2, GetMaxName) #starting values for all, final values for majrule
aa.optim.full.list <- aa.optim
codon.freq.by.aa <- GetCodonFreqsByAA(codon.data[,-1], aa.optim, numcode=1)
codon.freq.by.gene <- GetCodonFreqsByGeneHMM(codon.data[,-1])
aa.optim.frame.to.add <- matrix(c("optimal", aa.optim), 1, dim(codon.data)[2])
colnames(aa.optim.frame.to.add) <- colnames(codon.data)
codon.data <- rbind(codon.data, aa.optim.frame.to.add)
codon.data <- SitePattern(codon.data, includes.optimal.aa=TRUE)
aa.optim = codon.data$optimal.aa
codon.index.matrix <- CreateCodonMutationMatrixIndexEvolveAA()
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
source('~/GitHub/selac/R/selac.R')
#GLIK
GetLikelihoodSAC_CodonForSingleCharGivenOptimumHMMScoring <- function(charnum=1, codon.data, phy, Q_codon_array_vectored, root.p=NULL, scale.factor, anc.indices, return.all=FALSE) {
nb.tip <- length(phy$tip.label)
nb.node <- phy$Nnode
nl <- 64
#Now we need to build the matrix of likelihoods to pass to dev.raydisc:
liks <- matrix(0, nb.tip + nb.node, nl)
tip.idx <- 1:nb.tip
c.idx <- codon.data[tip.idx, charnum + 1] < 65
liks[tip.idx[c.idx], codon.data[tip.idx[c.idx], charnum + 1]] <- 1
liks[tip.idx[!c.idx], ] <- 1
liks[tip.idx[!c.idx], c(49, 51, 57)] <- 0
## Now HMM this matrix by pasting these together:
liks.stop.codon <- matrix(0,  nb.tip + nb.node, nl)
liks.HMM <- vector("list", 21)
liks.HMM[1:16] <- replicate(expr = liks, n = 16, simplify = FALSE)
liks.HMM[[17]] <- liks.stop.codon
liks.HMM[18:21] <- replicate(expr = liks, n = 4, simplify = FALSE)
liks.HMM <- do.call(cbind, liks.HMM)
#The result here is just the likelihood:
result <- -TreeTraversalODE(phy=phy, Q_codon_array_vectored=Q_codon_array_vectored, liks.HMM=liks.HMM, bad.likelihood=-100000, root.p=root.p)
ifelse(return.all, stop("return all not currently implemented"), return(result))
}
tree <- read.tree("../tests/testthat/rokasYeast.tre")
phy <- drop.tip(tree, "Calb")
phy <- reorder(x = phy, "pruningwise")
yeast.gene <- read.dna("../tests/testthat/gene1Yeast.fasta", format="fasta")
yeast.gene <- as.list(as.matrix(cbind(yeast.gene))[1:7,])
chars <- DNAbinToCodonNumeric(yeast.gene)
codon.data <- chars[phy$tip.label,]
aa.data <- ConvertCodonNumericDataToAAData(codon.data, numcode=1)
aa.optim <- apply(aa.data[, -1], 2, GetMaxName) #starting values for all, final values for majrule
aa.optim.full.list <- aa.optim
codon.freq.by.aa <- GetCodonFreqsByAA(codon.data[,-1], aa.optim, numcode=1)
codon.freq.by.gene <- GetCodonFreqsByGeneHMM(codon.data[,-1])
aa.optim.frame.to.add <- matrix(c("optimal", aa.optim), 1, dim(codon.data)[2])
colnames(aa.optim.frame.to.add) <- colnames(codon.data)
codon.data <- rbind(codon.data, aa.optim.frame.to.add)
codon.data <- SitePattern(codon.data, includes.optimal.aa=TRUE)
aa.optim = codon.data$optimal.aa
codon.index.matrix <- CreateCodonMutationMatrixIndexEvolveAA()
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
source('~/GitHub/selac/R/selac.R')
#FCPM
FastCreateAllCodonFixationProbabilityMatrices <- function(aa.distances=CreateAADistanceMatrix(), nsites, C=4, Phi=0.5, q=4e-7, Ne=5e6, include.stop.codon=TRUE, numcode=1, diploid=TRUE, flee.stop.codon.rate=0.9999999) {
n.codons <- dim(.codon.sets)[1]
aa.fixation.probs <- CreateAAFixationMatrixForEverything(aa.distances=aa.distances, nsites, C, Phi, q, Ne, include.stop.codon, numcode, diploid)
codon.aa <- .aa.translation[[.numcode.translation.idx[numcode]]]
codon.fixation.probs <- array(data=0, dim=c(n.codons, n.codons, length(.unique.aa)), dimnames=list(.codon.name, .codon.name, .unique.aa))
codon.seq <- sequence(n.codons)
for (i in codon.seq) {
aa1 <- codon.aa[i]
for (j in codon.seq) {
aa2 <- codon.aa[j]
if(sum(.codon.sets[i,] == .codon.sets[j,]) > 1) { #match at two or more sites
codon.fixation.probs[i,j, ] <- aa.fixation.probs[aa1, aa2, .unique.aa]
}
}
}
return(codon.fixation.probs)
}
#TTODE
TreeTraversalODE <- function(phy, Q_codon_array_vectored, liks.HMM, bad.likelihood=-100000, root.p) {
nb.tip <- length(phy$tip.label)
nb.node <- phy$Nnode
anc <- unique(phy$edge[,1])
TIPS <- 1:nb.tip
n.states <- dim(liks.HMM)[2]
comp <- numeric(nb.tip + nb.node)
num.desc <- table(phy$edge[,1])
num.desc.cs <- c(0, cumsum(num.desc))
#Start the postorder traversal indexing lists by node number:
for (i in 1:nb.node) {
focal <- anc[i]
desRows <- (num.desc.cs[i]+1):num.desc.cs[i+1]
desNodes <- phy$edge[desRows, 2]
v = rep(1, n.states)
for (desIndex in 1:num.desc[i]){
yini <- liks.HMM[desNodes[desIndex],]
times=c(0, phy$edge.length[desRows[desIndex]])
prob.subtree.cal.full <- lsoda(yini, times, func = "selacHMM", Q_codon_array_vectored, initfunc="initmod_selacHMM", dllname = "selacHMM")
######## THIS CHECKS TO ENSURE THAT THE INTEGRATION WAS SUCCESSFUL ###########
if(attributes(prob.subtree.cal.full)$istate[1] < 0){
return(bad.likelihood)
}else{
prob.subtree.cal <- prob.subtree.cal.full[-1,-1]
}
##############################################################################
if(prob.subtree.cal[1] < 0){
return(bad.likelihood)
}
v <- v * prob.subtree.cal
}
comp[focal] <- sum(v)
liks.HMM[focal,] <- v/comp[focal]
}
root.node <- nb.tip + 1L
if (is.na(sum(log(liks.HMM[root.node,])))){
return(bad.likelihood)
}else{
loglik <- -(sum(log(comp[-TIPS])) + log(sum(root.p * liks.HMM[root.node,])))
}
return(loglik)
}
tree <- read.tree("../tests/testthat/rokasYeast.tre")
phy <- drop.tip(tree, "Calb")
phy <- reorder(x = phy, "pruningwise")
yeast.gene <- read.dna("../tests/testthat/gene1Yeast.fasta", format="fasta")
yeast.gene <- as.list(as.matrix(cbind(yeast.gene))[1:7,])
chars <- DNAbinToCodonNumeric(yeast.gene)
codon.data <- chars[phy$tip.label,]
aa.data <- ConvertCodonNumericDataToAAData(codon.data, numcode=1)
aa.optim <- apply(aa.data[, -1], 2, GetMaxName) #starting values for all, final values for majrule
aa.optim.full.list <- aa.optim
codon.freq.by.aa <- GetCodonFreqsByAA(codon.data[,-1], aa.optim, numcode=1)
codon.freq.by.gene <- GetCodonFreqsByGeneHMM(codon.data[,-1])
aa.optim.frame.to.add <- matrix(c("optimal", aa.optim), 1, dim(codon.data)[2])
colnames(aa.optim.frame.to.add) <- colnames(codon.data)
codon.data <- rbind(codon.data, aa.optim.frame.to.add)
codon.data <- SitePattern(codon.data, includes.optimal.aa=TRUE)
aa.optim = codon.data$optimal.aa
codon.index.matrix <- CreateCodonMutationMatrixIndexEvolveAA()
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
source('~/GitHub/selac/R/selac.R')
#FCPM
FastCreateAllCodonFixationProbabilityMatrices <- function(aa.distances=CreateAADistanceMatrix(), nsites, C=4, Phi=0.5, q=4e-7, Ne=5e6, include.stop.codon=TRUE, numcode=1, diploid=TRUE, flee.stop.codon.rate=0.9999999) {
n.codons <- dim(.codon.sets)[1]
aa.fixation.probs <- CreateAAFixationMatrixForEverything(aa.distances=aa.distances, nsites, C, Phi, q, Ne, include.stop.codon, numcode, diploid)
codon.aa <- .aa.translation[[.numcode.translation.idx[numcode]]]
codon.fixation.probs <- array(data=0, dim=c(n.codons, n.codons, length(.unique.aa)), dimnames=list(.codon.name, .codon.name, .unique.aa))
codon.seq <- sequence(n.codons)
for (i in codon.seq) {
aa1 <- codon.aa[i]
for (j in codon.seq) {
aa2 <- codon.aa[j]
if(sum(.codon.sets[i,] == .codon.sets[j,]) > 1) { #match at two or more sites
codon.fixation.probs[i,j, ] <- aa.fixation.probs[aa1, aa2, .unique.aa]
}
}
}
return(codon.fixation.probs)
}
#GLIK
GetLikelihoodSAC_CodonForSingleCharGivenOptimumHMMScoring <- function(charnum=1, codon.data, phy, Q_codon_array_vectored, root.p=NULL, scale.factor, anc.indices, return.all=FALSE) {
nb.tip <- length(phy$tip.label)
nb.node <- phy$Nnode
nl <- 64
#Now we need to build the matrix of likelihoods to pass to dev.raydisc:
liks <- matrix(0, nb.tip + nb.node, nl)
tip.idx <- 1:nb.tip
c.idx <- codon.data[tip.idx, charnum + 1] < 65
liks[tip.idx[c.idx], codon.data[tip.idx[c.idx], charnum + 1]] <- 1
liks[tip.idx[!c.idx], ] <- 1
liks[tip.idx[!c.idx], c(49, 51, 57)] <- 0
## Now HMM this matrix by pasting these together:
liks.stop.codon <- matrix(0,  nb.tip + nb.node, nl)
liks.HMM <- vector("list", 21)
liks.HMM[1:16] <- replicate(expr = liks, n = 16, simplify = FALSE)
liks.HMM[[17]] <- liks.stop.codon
liks.HMM[18:21] <- replicate(expr = liks, n = 4, simplify = FALSE)
liks.HMM <- do.call(cbind, liks.HMM)
#The result here is just the likelihood:
result <- -TreeTraversalODE(phy=phy, Q_codon_array_vectored=Q_codon_array_vectored, liks.HMM=liks.HMM, bad.likelihood=-100000, root.p=root.p)
ifelse(return.all, stop("return all not currently implemented"), return(result))
}
tree <- read.tree("../tests/testthat/rokasYeast.tre")
phy <- drop.tip(tree, "Calb")
phy <- reorder(x = phy, "pruningwise")
yeast.gene <- read.dna("../tests/testthat/gene1Yeast.fasta", format="fasta")
yeast.gene <- as.list(as.matrix(cbind(yeast.gene))[1:7,])
chars <- DNAbinToCodonNumeric(yeast.gene)
codon.data <- chars[phy$tip.label,]
aa.data <- ConvertCodonNumericDataToAAData(codon.data, numcode=1)
aa.optim <- apply(aa.data[, -1], 2, GetMaxName) #starting values for all, final values for majrule
aa.optim.full.list <- aa.optim
codon.freq.by.aa <- GetCodonFreqsByAA(codon.data[,-1], aa.optim, numcode=1)
codon.freq.by.gene <- GetCodonFreqsByGeneHMM(codon.data[,-1])
aa.optim.frame.to.add <- matrix(c("optimal", aa.optim), 1, dim(codon.data)[2])
colnames(aa.optim.frame.to.add) <- colnames(codon.data)
codon.data <- rbind(codon.data, aa.optim.frame.to.add)
codon.data <- SitePattern(codon.data, includes.optimal.aa=TRUE)
aa.optim = codon.data$optimal.aa
codon.index.matrix <- CreateCodonMutationMatrixIndexEvolveAA()
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
source('~/GitHub/selac/R/selac.R')
#TTODE
TreeTraversalODE <- function(phy, Q_codon_array_vectored, liks.HMM, bad.likelihood=-100000, root.p) {
nb.tip <- length(phy$tip.label)
nb.node <- phy$Nnode
anc <- unique(phy$edge[,1])
TIPS <- 1:nb.tip
n.states <- dim(liks.HMM)[2]
comp <- numeric(nb.tip + nb.node)
num.desc <- table(phy$edge[,1])
num.desc.cs <- c(0, cumsum(num.desc))
#Start the postorder traversal indexing lists by node number:
for (i in 1:nb.node) {
focal <- anc[i]
desRows <- (num.desc.cs[i]+1):num.desc.cs[i+1]
desNodes <- phy$edge[desRows, 2]
v = rep(1, n.states)
for (desIndex in 1:num.desc[i]){
yini <- liks.HMM[desNodes[desIndex],]
times=c(0, phy$edge.length[desRows[desIndex]])
prob.subtree.cal.full <- lsoda(yini, times, func = "selacHMM", Q_codon_array_vectored, initfunc="initmod_selacHMM", dllname = "selacHMM")
######## THIS CHECKS TO ENSURE THAT THE INTEGRATION WAS SUCCESSFUL ###########
if(attributes(prob.subtree.cal.full)$istate[1] < 0){
return(bad.likelihood)
}else{
prob.subtree.cal <- prob.subtree.cal.full[-1,-1]
}
##############################################################################
if(prob.subtree.cal[1] < 0){
return(bad.likelihood)
}
v <- v * prob.subtree.cal
}
comp[focal] <- sum(v)
liks.HMM[focal,] <- v/comp[focal]
}
root.node <- nb.tip + 1L
if (is.na(sum(log(liks.HMM[root.node,])))){
return(bad.likelihood)
}else{
loglik <- -(sum(log(comp[-TIPS])) + log(sum(root.p * liks.HMM[root.node,])))
}
return(loglik)
}
#GLIK
GetLikelihoodSAC_CodonForSingleCharGivenOptimumHMMScoring <- function(charnum=1, codon.data, phy, Q_codon_array_vectored, root.p=NULL, scale.factor, anc.indices, return.all=FALSE) {
nb.tip <- length(phy$tip.label)
nb.node <- phy$Nnode
nl <- 64
#Now we need to build the matrix of likelihoods to pass to dev.raydisc:
liks <- matrix(0, nb.tip + nb.node, nl)
tip.idx <- 1:nb.tip
c.idx <- codon.data[tip.idx, charnum + 1] < 65
liks[tip.idx[c.idx], codon.data[tip.idx[c.idx], charnum + 1]] <- 1
liks[tip.idx[!c.idx], ] <- 1
liks[tip.idx[!c.idx], c(49, 51, 57)] <- 0
## Now HMM this matrix by pasting these together:
liks.stop.codon <- matrix(0,  nb.tip + nb.node, nl)
liks.HMM <- vector("list", 21)
liks.HMM[1:16] <- replicate(expr = liks, n = 16, simplify = FALSE)
liks.HMM[[17]] <- liks.stop.codon
liks.HMM[18:21] <- replicate(expr = liks, n = 4, simplify = FALSE)
liks.HMM <- do.call(cbind, liks.HMM)
#The result here is just the likelihood:
result <- -TreeTraversalODE(phy=phy, Q_codon_array_vectored=Q_codon_array_vectored, liks.HMM=liks.HMM, bad.likelihood=-100000, root.p=root.p)
ifelse(return.all, stop("return all not currently implemented"), return(result))
}
tree <- read.tree("../tests/testthat/rokasYeast.tre")
phy <- drop.tip(tree, "Calb")
phy <- reorder(x = phy, "pruningwise")
yeast.gene <- read.dna("../tests/testthat/gene1Yeast.fasta", format="fasta")
yeast.gene <- as.list(as.matrix(cbind(yeast.gene))[1:7,])
chars <- DNAbinToCodonNumeric(yeast.gene)
codon.data <- chars[phy$tip.label,]
aa.data <- ConvertCodonNumericDataToAAData(codon.data, numcode=1)
aa.optim <- apply(aa.data[, -1], 2, GetMaxName) #starting values for all, final values for majrule
aa.optim.full.list <- aa.optim
codon.freq.by.aa <- GetCodonFreqsByAA(codon.data[,-1], aa.optim, numcode=1)
codon.freq.by.gene <- GetCodonFreqsByGeneHMM(codon.data[,-1])
aa.optim.frame.to.add <- matrix(c("optimal", aa.optim), 1, dim(codon.data)[2])
colnames(aa.optim.frame.to.add) <- colnames(codon.data)
codon.data <- rbind(codon.data, aa.optim.frame.to.add)
codon.data <- SitePattern(codon.data, includes.optimal.aa=TRUE)
aa.optim = codon.data$optimal.aa
codon.index.matrix <- CreateCodonMutationMatrixIndexEvolveAA()
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
system.time(selac.unrest.evolveAA <- GetLikelihoodSAC_CodonForManyCharGivenAllParamsEvolvingAA(log(c(4*4e-7*.5*5e6, 1.829272, 0.101799, rep(1,11), 0.01)), codon.data, phy, codon.freq.by.aa=codon.freq.by.aa, codon.freq.by.gene=codon.freq.by.gene, numcode=1, diploid=TRUE, aa.properties=NULL, volume.fixed.value=0.0003990333, nuc.model="UNREST", codon.index.matrix, include.gamma=FALSE, ncats=4, k.levels=0, logspace=TRUE, verbose=FALSE, parallel.type="by.gene", n.cores=NULL))
